@_phaseControlFsm.txt 分析该爬升阶段，现在我需要在爬升阶段结束后，(应该是P4)减少到400血之后(这里应该是HP Check4状态)让BOSS进入一个全新的大招阶段，如同之前的大丝球阶段。只是实现形式有所不同，我们可以在PhaseControl加一个fsm变量来标识这个大招是否使用过，大招名字代码可以以PinArray类似的去命名。HP Check 4增加一个判断如果刚刚的变量为true可使用的情况加上boss血量是否少于400，类似原版的CompareHP，如果成立，则进入我们的新状态链，状态链中要设定那个变量为false以防再次触发该状态链。状态链大致分为prepare准备，这里调整BOSS的状态，并从FWPinManager中获取40把飞针为后续做准备，也要获取两个Hand或者6个FingerBlade，然后进入下一个阶段，剑阵召唤并展开，在场地中上召唤40把Pin飞剑阵，并将FingerBlade(可能需要通过Hand控制？需要分析其FSM)(分为两组，Hand L控制一组 Hand R控制一组)分别移动到左，中，右三个位置，L移动到上方的，R移动到下方的。这里可以参考和采用原版状态AnimatePositionTo来移动位置，然后从此这Finger开始瞄准玩家。40把Pin飞剑旋转着从一个点横向展开，这里的旋转不是说其本身的瞄准或攻击角度旋转，而是围绕着这个召唤点，大致结合Z轴变化和主要是位置变化，每根Pin的间隔是固定的，所以每个都有不同的初始偏移量。随着绕中心点旋转，半径扩大，同时也要注意最后的Z轴全部重设为0(这期间Pin的角度为朝下)，然后让一半的Pin朝下攻击，这里展开之后应该是在一个水平Y轴都向下的情况，然后隔一个Pin一个就向下攻击，所以这里应该在初期就对这两波Pin进行分组。砸地之后先不返回池，而是向上移动一点点并调整角度指向中间，(这里可能要去重新看一下@_pinProjectileFsm.txt 之前攻击了之后会自动重置一些东西并返回池内)但是是随机打乱角度，但下方的都是指向上半部分，上方的都是指向下半部分。这部分准备完成后，可以进入下一个状态Attack，刚刚主要是移动和分组，可以作为另一个状态。攻击状态中则开始发射所有Pin，需要一个个发射不是齐射，开始时发射间隔较长，0.8s，每发射三个Pin加速0.1s，最低0.2s，然后在这个发射期间之前的Finger也要随之发射。这里的Pin发射过就真的回收了。最后发射状态结束后回到P4状态，然后这时应该就能完成整个流程，因为变量失效也不会再次触发这个攻击，请你仔细思考上述流程，可能要多拆分若干状态，拥有若干行为，请多使用自带行为/自定义行为少使用CallMethod，不过也是可以使用的。@FsmState.cs 相关的其他文件你也可以分析，然后请你根据上述流程和行为帮我先构建一个计划，不要实现，先构建完整的逻辑链路，给出每个状态和其中的行为，可以添加几个自定义的行为或者CallMethod，但是要说明其作用和如何做的。@PinArrayControlAction.cs 这里是之前写的，应该完全不能用，但是少部分可以参考。
@AnimatePositionTo.cs @AnimatePositionToV2.cs @HutongGames.PlayMaker.Actions @FingerBladeControlFSM.txt @handFSM.txt 上述是目前可能会需要用到的文件，你可以去快速分析一下。你提到“砸地后不返回池，而是向上移动一点点再调整角度”——这与当前 Pin FSM 是冲突的：这个流程我认为可以让那个需要向下砸地的那组Pin去复制一下Fire/Thunk状态，然后完成之后恢复某些参数让他可以再次攻击，然后进入向上抬起状态，然后等待打乱角度和攻击事件同样进入原本的Pin，这里的事件接收和原本流程Fire的事件一样，到时候就直接给所有Array的发送同样事件即可。FingerBlade 的“瞄准/发射确实可以直接复用Shoot即可，不过原版的Shoot是让FingerBlade自己发射，然后我加了个多一段Pin，这个我是都要保留的：即我又要发射Finger也要Pin，但是这里我们是要添加一个控制方向的状态的，进入大招之后，要控制(可能可以使用AnimatePositionTo去移动他)Finger到指定的位置，之后进入锁头状态，去让自己的角度和攻击角度对准玩家，这里要注意原版的角度可能会比较绕Attack Angle，这个在Antic Pull状态还进行了add180，不过我们也可以之前的一串之后指向到这里，省的麻烦。HP Check 4 的改造按照你这种说法来。PinArray Roar可以需要。然后这里不需要改变BOSS层级，然后还是要小心和注意不同的State里怎么共享四十根Pin，我觉得可能可以使用FsmArray或者按照你的更好的方法。不过写一个List<GameObject>也是可以的。然后从中心点生成Pin，然后我认为大概率是绕Y轴来进行旋转，但是也有点不好说，暂时做成这样，按召唤时的中心点来旋转，这样会显得他们Y都是水平的，(这时Z可能会有变化)不过最后的时候展开完毕还是要恢复他们的Z都为0的。总之这里比较类似于DNF的剑圣的极·鬼剑术暴风式，如果可以的话你可以大致搜一下。然后Finger发射我希望是根据总时长来确定的，计算出总共的Pin的攻击时长，然后每六分之一的时长去额外发射一个锁头的Finger。然后根据上面的描述去仔细分析我的意思.